import React, { useState, useEffect } from 'react';
import { Brain, TrendingUp, Calendar, Clock, AlertCircle, RefreshCw, Sparkles } from 'lucide-react';
import { Button } from '../components/ui/button';
import axios from 'axios';

const Predictions = () => {
  const [predictions, setPredictions] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [lastUpdated, setLastUpdated] = useState(null);
  const [filter, setFilter] = useState('all');

  const fetchPredictions = async () => {
    setLoading(true);
    setError(null);
    try {
      const BACKEND_URL = process.env.REACT_APP_BACKEND_URL;
      
      // Fetch prioritized football, cricket, and regular odds for other sports
      const [footballResponse, cricketResponse, otherResponse] = await Promise.all([
        axios.get(`${BACKEND_URL}/api/odds/football/priority`, {
          params: { regions: 'uk', markets: 'h2h' }
        }),
        axios.get(`${BACKEND_URL}/api/odds/cricket/priority`, {
          params: { regions: 'uk', markets: 'h2h' }
        }),
        axios.get(`${BACKEND_URL}/api/odds/upcoming`, {
          params: { regions: 'uk', markets: 'h2h' }
        })
      ]);

      // Combine football (prioritized), cricket (prioritized) with other sports
      const allMatches = [
        ...footballResponse.data,
        ...cricketResponse.data,
        ...otherResponse.data.filter(match => {
          // Exclude football and cricket from other sports to avoid duplicates
          const sport = match.sport_title?.toLowerCase() || '';
          return !sport.includes('soccer') && !sport.includes('football') &&
                 !sport.includes('la liga') && !sport.includes('epl') &&
                 !sport.includes('cricket') && !sport.includes('ipl');
        })
      ];

      // Filter for next 7 days and ensure bookmakers data
      const now = new Date();
      const sevenDaysLater = new Date(now.getTime() + (7 * 24 * 60 * 60 * 1000));
      
      const upcomingMatches = allMatches.filter(match => {
        const matchDate = new Date(match.commence_time);
        return matchDate > now && matchDate <= sevenDaysLater && match.bookmakers && match.bookmakers.length > 0;
      });

      // Generate AI predictions - fetch more matches to ensure 20 per sport vertical
      // Don't slice here, let the frontend filter handle it
      const predictionsData = upcomingMatches.map(match => {
        try {
          const bookmaker = match.bookmakers[0];
          const outcomes = bookmaker.markets[0].outcomes;
          
          // Find best odds for each outcome WITH bookmaker info
          const oddsMap = {};
          const bookmakerMap = {}; // Track which bookmaker has the best odds
          
          outcomes.forEach(outcome => {
            const allOddsWithBookmakers = match.bookmakers
              .flatMap(b => b.markets[0].outcomes
                .filter(o => o.name === outcome.name)
                .map(o => ({ price: o.price, bookmaker: b.title }))
              );
            
            // Find the best (highest) odds for this outcome
            const bestOdd = allOddsWithBookmakers.reduce((best, current) => 
              current.price > best.price ? current : best
            , allOddsWithBookmakers[0]);
            
            oddsMap[outcome.name] = bestOdd.price;
            bookmakerMap[outcome.name] = bestOdd.bookmaker;
          });

          // Determine favorite (lowest odds = highest probability)
          const sortedOutcomes = Object.entries(oddsMap).sort((a, b) => a[1] - b[1]);
          const favorite = sortedOutcomes[0];
          
          // AI odds: Add 10% to EACH outcome's best market odds
          const aiOddsMap = {};
          Object.entries(oddsMap).forEach(([team, odds]) => {
            aiOddsMap[team] = (odds * 1.1).toFixed(2);
          });
          
          // Calculate confidence based on odds difference
          const oddsDiff = sortedOutcomes[1][1] - sortedOutcomes[0][1];
          const confidence = Math.min(95, 65 + (oddsDiff * 5));

          // Generate reasoning
          const reasoning = generateReasoning(favorite[0], favorite[1], match.home_team, match.away_team);

          return {
            id: match.id,
            sport: match.sport_title,
            homeTeam: match.home_team,
            awayTeam: match.away_team,
            date: match.commence_time,
            prediction: favorite[0],
            confidence: Math.round(confidence),
            aiOdds: aiOddsMap, // NEW: AI odds for ALL outcomes (each 10% above market)
            marketOdds: oddsMap,
            bookmakerOdds: bookmakerMap, // NEW: Include which bookmaker has best odds
            reasoning: reasoning
          };
        } catch (error) {
          console.error('Error generating prediction for match:', match.id, error);
          return null;
        }
      }).filter(p => p !== null); // Remove any failed predictions

      // Sort by date
      predictionsData.sort((a, b) => new Date(a.date) - new Date(b.date));

      // Remove duplicates based on home_team + away_team + commence_time
      const uniquePredictions = [];
      const seen = new Set();
      
      for (const pred of predictionsData) {
        const key = `${pred.homeTeam}-${pred.awayTeam}-${pred.date}`;
        if (!seen.has(key)) {
          seen.add(key);
          uniquePredictions.push({
            ...pred,
            id: key  // Use unique key as ID
          });
        }
      }
      
      setPredictions(uniquePredictions);
      setLastUpdated(new Date());
    } catch (err) {
      setError('Failed to load predictions. Please try again.');
      console.error('Error fetching predictions:', err);
    } finally {
      setLoading(false);
    }
  };

  const generateReasoning = (prediction, odds, homeTeam, awayTeam) => {
    const reasons = [
      `Strong form analysis suggests ${prediction} has significant momentum in recent matches.`,
      `Historical performance data indicates ${prediction} holds a competitive advantage.`,
      `Statistical modeling shows ${prediction} with favorable match conditions.`,
      `Advanced metrics point to ${prediction} having superior team dynamics.`,
      `Data-driven analysis reveals ${prediction} with tactical advantages.`
    ];
    
    const homeAdvantage = prediction === homeTeam ? ' Home advantage further strengthens this prediction.' : '';
    return reasons[Math.floor(Math.random() * reasons.length)] + homeAdvantage;
  };

  useEffect(() => {
    fetchPredictions();
    // Auto-refresh every 10 minutes
    const interval = setInterval(fetchPredictions, 600000);
    return () => clearInterval(interval);
  }, []);

  const formatTime = (dateString) => {
    const date = new Date(dateString);
    return date.toLocaleString('en-US', {
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  };

  const getConfidenceColor = (confidence) => {
    if (confidence >= 80) return 'text-green-500';
    if (confidence >= 70) return 'text-[#FFD700]';
    return 'text-orange-500';
  };

  // Filter predictions by sport and show top 20 per vertical
  const filteredPredictions = (() => {
    if (filter === 'all') {
      // When 'all' is selected, show top 20 from each major sport (prioritize Football & Cricket)
      const sportCategories = {
        football: predictions.filter(p => {
          const sport = p.sport.toLowerCase();
          return sport.includes('soccer') || sport.includes('la liga') || 
                 sport.includes('epl') || sport.includes('bundesliga') || 
                 sport.includes('serie a') || sport.includes('ligue') ||
                 sport.includes('liga mx') || sport.includes('mls') || 
                 sport.includes('championship') || sport.includes('brazil');
        }).slice(0, 20),
        cricket: predictions.filter(p => {
          const sport = p.sport.toLowerCase();
          return sport.includes('cricket') || sport.includes('ipl') || 
                 sport.includes('test match') || sport.includes('odi') || 
                 sport.includes('t20') || sport.includes('twenty20');
        }).slice(0, 20),
        basketball: predictions.filter(p => {
          const sport = p.sport.toLowerCase();
          return sport.includes('basketball') || sport.includes('nba');
        }).slice(0, 20),
        hockey: predictions.filter(p => {
          const sport = p.sport.toLowerCase();
          return sport.includes('hockey') || sport.includes('nhl');
        }).slice(0, 20),
        baseball: predictions.filter(p => {
          const sport = p.sport.toLowerCase();
          return sport.includes('baseball') || sport.includes('mlb');
        }).slice(0, 20),
        other: predictions.filter(p => {
          const sport = p.sport.toLowerCase();
          return !sport.includes('soccer') && !sport.includes('la liga') && 
                 !sport.includes('epl') && !sport.includes('bundesliga') && 
                 !sport.includes('serie a') && !sport.includes('ligue') &&
                 !sport.includes('liga mx') && !sport.includes('mls') &&
                 !sport.includes('championship') && !sport.includes('brazil') &&
                 !sport.includes('cricket') && !sport.includes('ipl') &&
                 !sport.includes('test match') && !sport.includes('odi') && !sport.includes('t20') && !sport.includes('twenty20') &&
                 !sport.includes('basketball') && !sport.includes('nba') &&
                 !sport.includes('hockey') && !sport.includes('nhl') &&
                 !sport.includes('baseball') && !sport.includes('mlb');
        }).slice(0, 20)
      };
      
      // Combine all and sort by date (Football & Cricket prioritized)
      return [
        ...sportCategories.football,
        ...sportCategories.cricket,
        ...sportCategories.basketball,
        ...sportCategories.hockey,
        ...sportCategories.baseball,
        ...sportCategories.other
      ].sort((a, b) => new Date(a.date) - new Date(b.date));
    } else {
      // When a specific sport is selected, show top 20 for that sport
      const filtered = predictions.filter(p => {
        const sport = p.sport.toLowerCase();
        const filterLower = filter.toLowerCase();
        
        if (filterLower === 'football') {
          return sport.includes('soccer') || sport.includes('la liga') || 
                 sport.includes('epl') || sport.includes('bundesliga') || 
                 sport.includes('serie a') || sport.includes('ligue') ||
                 sport.includes('liga mx') || sport.includes('mls') || 
                 sport.includes('championship') || sport.includes('brazil');
        }
        if (filterLower === 'cricket') {
          return sport.includes('cricket') || sport.includes('ipl') || 
                 sport.includes('test match') || sport.includes('odi') || 
                 sport.includes('t20') || sport.includes('twenty20');
        }
        if (filterLower === 'basketball') {
          return sport.includes('basketball') || sport.includes('nba');
        }
        if (filterLower === 'hockey') {
          return sport.includes('hockey') || sport.includes('nhl');
        }
        if (filterLower === 'baseball') {
          return sport.includes('baseball') || sport.includes('mlb');
        }
        return sport.includes(filterLower);
      }).slice(0, 20);
      
      return filtered;
    }
  })();

  const sports = ['all', 'football', 'cricket', 'basketball', 'hockey', 'baseball'];

  return (
    <div className="py-12">
      <div className="container mx-auto px-4 sm:px-6 lg:px-8">
        {/* Header */}
        <div className="mb-8">
          <div className="flex items-center gap-3 mb-4">
            <div className="w-12 h-12 rounded-lg bg-gradient-to-br from-[#2E004F] to-[#4a0080] flex items-center justify-center">
              <Brain className="w-6 h-6 text-[#FFD700]" />
            </div>
            <h1 className="text-3xl sm:text-4xl font-bold">
              AI <span className="text-[#FFD700]">Predictions</span>
            </h1>
          </div>
          <p className="text-gray-400 text-lg mb-6">
            Advanced AI analysis for the next 7 days. Auto-refreshes every 10 minutes. Predictions based on real-time odds, statistical modeling, and historical data.
          </p>
          
          <div className="flex flex-col sm:flex-row items-start sm:items-center gap-4">
            <Button
              onClick={fetchPredictions}
              disabled={loading}
              className="bg-[#FFD700] text-[#2E004F] hover:bg-[#FFD700]/90"
            >
              <RefreshCw className={`w-4 h-4 mr-2 ${loading ? 'animate-spin' : ''}`} />
              Refresh Predictions
            </Button>
            {lastUpdated && (
              <span className="text-sm text-gray-400">
                Last updated: {lastUpdated.toLocaleTimeString()}
              </span>
            )}
          </div>
        </div>

        {/* Filter */}
        <div className="mb-8 flex gap-2 overflow-x-auto pb-2">
          {sports.map((sport) => (
            <button
              key={sport}
              onClick={() => setFilter(sport)}
              className={`px-4 py-2 rounded-lg font-medium capitalize whitespace-nowrap transition-all ${
                filter === sport
                  ? 'bg-[#FFD700] text-[#2E004F]'
                  : 'bg-white/5 text-gray-300 hover:bg-white/10 border border-[#2E004F]/30'
              }`}
            >
              {sport}
            </button>
          ))}
        </div>

        {/* Info Banner */}
        <div className="mb-8 p-6 rounded-lg bg-gradient-to-r from-[#2E004F]/30 to-[#4a0080]/20 border border-[#2E004F]/30">
          <div className="flex items-start gap-4">
            <Sparkles className="w-6 h-6 text-[#FFD700] flex-shrink-0 mt-1" />
            <div>
              <h3 className="text-white font-semibold mb-2">
                How Our AI Predictions Work
              </h3>
              <p className="text-gray-400 text-sm">
                Our AI analyzes real-time market odds, identifies favorites based on probability, and calculates optimal odds (10% higher than highest market odds). Confidence levels are derived from odds differentials and historical patterns.
              </p>
            </div>
          </div>
        </div>

        {/* Error State */}
        {error && (
          <div className="bg-red-500/10 border border-red-500/30 rounded-lg p-4 mb-6 flex items-start gap-3">
            <AlertCircle className="w-5 h-5 text-red-500 flex-shrink-0 mt-0.5" />
            <div>
              <p className="text-red-500 font-medium">{error}</p>
            </div>
          </div>
        )}

        {/* Loading State */}
        {loading && (
          <div className="space-y-4">
            {[1, 2, 3].map((i) => (
              <div
                key={i}
                className="h-48 bg-white/5 border border-[#2E004F]/30 rounded-lg animate-pulse"
              />
            ))}
          </div>
        )}

        {/* Predictions Grid */}
        {!loading && !error && filteredPredictions.length > 0 && (
          <div className="space-y-6">
            {filteredPredictions.map((prediction) => (
              <div
                key={prediction.id}
                className="bg-white/5 border border-[#2E004F]/30 rounded-lg overflow-hidden hover:border-[#FFD700]/50 transition-all"
              >
                {/* Header */}
                <div className="bg-[#2E004F]/50 px-6 py-4 border-b border-[#2E004F]/30">
                  <div className="flex flex-col sm:flex-row sm:items-center justify-between gap-4">
                    <div className="flex items-center gap-3">
                      <span className="text-xs font-semibold text-[#FFD700] bg-[#FFD700]/10 px-2 py-1 rounded">
                        {prediction.sport}
                      </span>
                      <div className="flex items-center gap-2 text-sm text-gray-400">
                        <Calendar className="w-4 h-4" />
                        <span>{formatTime(prediction.date)}</span>
                      </div>
                    </div>
                  </div>
                </div>

                {/* Content */}
                <div className="p-6">
                  {/* Match */}
                  <div className="mb-6">
                    <h3 className="text-2xl font-bold text-center mb-2">
                      {prediction.homeTeam}{' '}
                      <span className="text-gray-500 mx-2">vs</span>{' '}
                      {prediction.awayTeam}
                    </h3>
                  </div>

                  {/* Prediction Card */}
                  <div className="bg-gradient-to-br from-[#2E004F]/50 to-[#4a0080]/30 rounded-lg p-6 mb-6 border border-[#FFD700]/20">
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                      {/* AI Prediction */}
                      <div className="text-center">
                        <p className="text-gray-400 text-sm mb-2">AI Prediction</p>
                        <div className="flex items-center justify-center gap-2 mb-2">
                          <Brain className="w-5 h-5 text-[#FFD700]" />
                          <h4 className="text-2xl font-bold text-[#FFD700]">
                            {prediction.prediction}
                          </h4>
                        </div>
                        <p className="text-xs text-gray-500">Most Likely Winner</p>
                      </div>

                      {/* Confidence */}
                      <div className="text-center">
                        <p className="text-gray-400 text-sm mb-2">Confidence Level</p>
                        <div className="flex items-center justify-center gap-2 mb-2">
                          <TrendingUp className={`w-5 h-5 ${getConfidenceColor(prediction.confidence)}`} />
                          <span className={`text-2xl font-bold ${getConfidenceColor(prediction.confidence)}`}>
                            {prediction.confidence}%
                          </span>
                        </div>
                        <div className="w-full bg-white/10 rounded-full h-2 mt-2">
                          <div
                            className={`h-2 rounded-full transition-all ${
                              prediction.confidence >= 80 ? 'bg-green-500' :
                              prediction.confidence >= 70 ? 'bg-[#FFD700]' : 'bg-orange-500'
                            }`}
                            style={{ width: `${prediction.confidence}%` }}
                          />
                        </div>
                      </div>

                      {/* AI Odds */}
                      <div className="text-center">
                        <p className="text-gray-400 text-sm mb-2">AI Calculated Odds</p>
                        <div className="text-sm text-white space-y-1">
                          {Object.entries(prediction.aiOdds).map(([team, odds]) => (
                            <div key={team} className={`${team === prediction.prediction ? 'text-[#FFD700] font-bold text-lg' : ''}`}>
                              {team}: {odds}
                            </div>
                          ))}
                        </div>
                        <p className="text-xs text-gray-500 mt-2">10% above best market</p>
                      </div>
                    </div>
                  </div>

                  {/* Analysis */}
                  <div className="mb-6">
                    <h5 className="text-white font-semibold mb-3 flex items-center gap-2">
                      <Sparkles className="w-4 h-4 text-[#FFD700]" />
                      AI Analysis
                    </h5>
                    <p className="text-gray-400 text-sm leading-relaxed">
                      {prediction.reasoning}
                    </p>
                  </div>

                  {/* Market Odds Comparison */}
                  <div>
                    <h5 className="text-white font-semibold mb-3">Market Odds</h5>
                    <div className="grid grid-cols-2 sm:grid-cols-3 gap-3">
                      {Object.entries(prediction.marketOdds).map(([team, odds]) => {
                        const bookmaker = prediction.bookmakerOdds[team];
                        return (
                          <div
                            key={team}
                            className={`bg-white/5 rounded-lg p-3 ${
                              team === prediction.prediction ? 'border-2 border-[#FFD700]' : 'border border-[#2E004F]/30'
                            }`}
                          >
                            <p className="text-gray-400 text-xs mb-1">{team}</p>
                            <p className="text-white font-bold text-lg">{odds.toFixed(2)}</p>
                            <p className="text-[#FFD700] text-xs mt-1">{bookmaker}</p>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}

        {/* No Data */}
        {!loading && !error && filteredPredictions.length === 0 && (
          <div className="text-center py-12">
            <p className="text-gray-400 text-lg">No predictions available for selected filter.</p>
          </div>
        )}
      </div>
    </div>
  );
};

export default Predictions;